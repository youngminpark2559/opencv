<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
   <HEAD>
      <TITLE>My first HTML document</TITLE>
      <style rel="stylesheet" type="text/css">
body {
 font-size: 23px;
 
 margin-top: 50px;
    margin-bottom: 50px;
    margin-right: 80px;
    margin-left: 80px;
    
    padding-top: 50px;
    padding-bottom: 50px;
    padding-right: 80px;
    padding-left: 80px;
    
    line-height:35px;
}
img {
 width:500px;
}
</style>
      <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    "HTML-CSS" : {
        availableFonts : ["STIX"],
        preferredFont : "STIX",
        webFont : "STIX-Web",
        imageFont : null
    }
});
</script>
     <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js" type="text/javascript">    
    MathJax.Hub.Config({
        HTML: ["input/TeX","output/HTML-CSS"],
        TeX: { extensions: ["AMSmath.js","AMSsymbols.js"], 
               equationNumbers: { autoNumber: "AMS" } },
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: { inlineMath: [ ['$$$','$$$'] ],
                   displayMath: [ ['$$$$','$$$$'] ],
                   processEscapes: true },
        "HTML-CSS": { availableFonts: ["TeX"],
                      linebreaks: { automatic: true } }
    });
</script>
   </HEAD>
   <BODY>
012 overview of image transform
<xmp>
012.html

overview of image transform

@
transform :
based on given function, you convert given data (image) composed of color or brightness into another type data like frequency data

Generally, color or brightness which pixel has is changed data which has value of frequency

Since data (like digital image) we use is discrete data (not continuous data), this transform is called "discrete transform" or "frequency transform"

@
In frequency transform,
input data is data defined in spatial domain (like 2d plane having pixels),
you map those data in frequency domain


@
Functions which are used for transformation are called basis function

Basis function you used much is sinusoidal (정형파 = sine or cosine or sine + cosine) or rectangular forms

@
Sine function : 
x axis : degree

Sine signal :
x axis : time

2018-06-05 13-40-58.png
</xmp><img src="https://raw.githubusercontent.com/youngmtool/opencv/master/sykim/pic/2018-06-05 13-40-58.png"><xmp>

@
transform:
projecting image into basis image (mask, basis function)
projecting process is inner product

basis vector set = {i,j} (length is 1)

You can project P onto x axis
Length becomes a

You can project P onto y axis
Length becomes b


@
transform is to change basis from xy basis to x'y' basis

2018-06-05 13-45-52.png
</xmp><img src="https://raw.githubusercontent.com/youngmtool/opencv/master/sykim/pic/2018-06-05 13-45-52.png"><xmp>

2018-06-05 13-46-07.png
</xmp><img src="https://raw.githubusercontent.com/youngmtool/opencv/master/sykim/pic/2018-06-05 13-46-07.png"><xmp>

In new basis x'y', point becomes (a',b') from (a,b)

@
spatial frequency
In space, how fast value changes?

high spatial frequency : entire image with rapidly changing brightness level
2018-06-05 13-58-28.png
</xmp><img src="https://raw.githubusercontent.com/youngmtool/opencv/master/sykim/pic/2018-06-05 13-58-28.png"><xmp>
f : 20 means 20 changes

low spatial frequency : entire image with slowly changing brightness level
2018-06-05 13-57-55.png
</xmp><img src="https://raw.githubusercontent.com/youngmtool/opencv/master/sykim/pic/2018-06-05 13-57-55.png"><xmp>

zeor spatial frequency : entire image with constant value (without changes)
2018-06-05 13-56-38.png
</xmp><img src="https://raw.githubusercontent.com/youngmtool/opencv/master/sykim/pic/2018-06-05 13-56-38.png"><xmp>
f : frequency
g : brightness

@
frequency 1 in sinusoidal wave
2018-06-05 14-00-14.png
</xmp><img src="https://raw.githubusercontent.com/youngmtool/opencv/master/sykim/pic/2018-06-05 14-00-14.png"><xmp>

frequency 2 (white, black, white, black) in sinusoidal wave
2018-06-05 14-01-14.png
</xmp><img src="https://raw.githubusercontent.com/youngmtool/opencv/master/sykim/pic/2018-06-05 14-01-14.png"><xmp>


@
General form of transformation

1. forward transformation
$$$T(u,v)=\sum\limits_{r=0}^{M-1}\sum\limits_{c=0}^{N-1} I(r,c) B(r,c;u,v)$$$

r, c : row and column
M-1, N-1 : ends of row and column
I(r,c) : input image
B(r,c;u,v) : basis image
T(u,v) : energy of frequency at (u,v), transform coefficients at (u,v)

variables in spatial domian : r and c representing color or brightness
variables in frequency domian : u and v representing frequency

2. backward (inverse) transformation
input : transform coefficients T(u,v) at (u,v), frequency domain data
output : original image I(r,c), spatial domain data

$$$I(r,c)=\sum\limits_{u=0}^{M-1}\sum\limits_{v=0}^{N-1} T(u,v) B^{-1}(r,c;u,v)$$$

$$$B^{-1}(r,c;u,v)$$$ : inverse of basis image


=========================================================
Characteristic of T(u,v)

Transformed data (transform coefficients at (u,v)) T(u,v) is projection of original input image I(r,c) onto each basis image B(u,v)
T(u,v) represents similarity of image I(r,c) to basis image B(u,v)

Basis images B(u,v) are orthogonal to each other

Image is decomposed into weigthed sum of basis images

=========================================================
Set of basis vectors : B(r,c;u,v)

In B(r,c;u,v),
v : 0, 1
u : 0, 1

2018-06-05 15-27-02.png
</xmp><img src="https://raw.githubusercontent.com/youngmtool/opencv/master/sykim/pic/2018-06-05 15-27-02.png"><xmp>

To be basis image, basis images should be orthogonal

basis image 1 : u=0, v=0
    changes = 0, frequency = 0
basis image 2 : u=0, v=1 
    horizontally changes = 1 (wb,wb), frequency = 1
    vertically changes = 0 (ww,bb), frequency = 0
basis image 3 : u=1, v=0
    horizontally changes = 0 (ww,bb), frequency = 0
    vertically changes = 1 (wb,wb), frequency = 1
basis image 4 : u=1, v=1
    horizontally changes = 1 (wb,bw), frequency = 1
    vertically changes = 1 (wb,bw), frequency = 1

basis image 1 : u=0, v=0 can detect empty part with high value from convolution operation
basis image 2 : u=0, v=1 can detect horizontall part with high value from convolution operation
basis image 3 : u=1, v=0 can detect vertical part with high value from convolution operation
basis image 4 : u=1, v=1 can detect horizontal and vertical part with high value from convolution operation
      
</xmp>
   </BODY>
</HTML>
